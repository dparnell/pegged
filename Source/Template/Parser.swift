//
//  Generated by pegged $Version
//  Fork: https://github.com/dparnell/pegged
//  File is auto-generated. Do not modify.
//

import Foundation
//!$Imports


let ParserClassErrorStringLocationKey = "ParserClassErrorStringLocation"
let ParserClassErrorStringLengthKey   = "ParserClassErrorStringLength"
let ParserClassErrorStringKey         = "ParserClassErrorString"
let ParserClassErrorTypeKey           = "ParserClassErrorType"

class ParserClass {
    /*!
    @abstract The last error state of the parser.
    @discussion ParserClassErrorStringLocationKey, ParserClassErrorStringLengthKey provides the index and length of the errorneous string (NSNumber), ParserClassErrorStringKey the errorneous string. ParserClassErrorTypeKey contains a grammar-dependent error key. The localized description of the error will be generated from the string file of the ParserClass, whereas the ParserClassErrorTypeKey will be used as localization string key.
    */    
    var lastError: NSError?
    
    /*!
    @abstract The start index of the current capture
    */
    var captureStart: Int = 0
    
    /*!
    @abstract The end index of the current capture
    */
    var captureEnd: Int = 0
    
    /*!
    @abstract The currently parsed string
    */
    var string: String = ""
    
    var _index: Int = 0
    var _limit: Int = 0
    var _lastError: NSError?
    
    /*!
    @abstract Parses the given string and passes the return value of the start rule as output argument.
    @discussion Returns YES on match.
    */
    func parseString(string:String, inout result:AnyObject?) -> Bool  {
        self.string = string
    }
    
    
    /*!
    @abstract Provides a result for the current rule
    */
    func pushResult(result: AnyObject) {
        
    }
    
    /*!
    @abstract Accesses the next result of a sub-rule
    */
    func nextResult() -> AnyObject? {
        
    }
    
    /*!
    @abstract Accesses the next result of a sub-rule, if a certain result count matches.
    @discussion Returns nil otherwise.
    */
    func nextResultIfCount(count: Int) -> AnyObject? {
        
    }
    
    /*!
    @abstract Accesses the next result of a sub-rule. Returns nil, if none is available
    */
    func nextResultOrNil() -> AnyObject? {
        
    }
    
    /*!
    @abstract Accesses the result of a sub-rule with a certain index
    */
    func resultAtIndex(index: Int) -> AnyObject? {
        
    }
    
    /*!
    @abstract Accesses the result of a sub-rule with a certain index. If the result does not exist, nil is returned.
    */
    func resultAtIndexIfAny(index:Int) -> AnyObject? {
        
    }
    
    /*!
    @abstract Provies all sub-rule results as array.
    */
    func allResults() -> NSArray {
        
    }
    
    /*!
    @abstract Provides the count of results.
    */
    func resultCount() -> Int {
        
    }
    
    /*!
    @abstract Provides the range of the current action
    */
    func rangeForCurrentAction() -> NSRange {
        
    }
    
    func beginCapture() {
        
    }
    
    func endCapture() {
        
    }
    
    func matchRule(ruleName: String, startIndex: Int, asserted: Bool) -> Bool
    {
        var rule = _rules[ruleName]
        var lastIndex = index
    
        // We are in an error state. Just stop.
        if (_lastError) {
            return false;
        }

        if(rule) {
            var localCaptures: Int = 0
            
            if (matchOneWithCaptures(capture:&localCaptures, startIndex:_index, block:rule)) {
                return true
            }
        } else {
            println("Couldn't find rule name \"\(ruleName)\".")
        }
        
        if (asserted) {
            setErrorWithMessage(message: "Unmatched\(ruleName)", location:lastIndex, length:(_index - lastIndex))
        }
    
    
        return false
    }
    
    func matchString(literal:String, startIndex: Int, asserted:Bool) -> Bool
    {
        var saved = _index;
        var L = literal.length
        var i = 0
        while (i<L) {
            if ((_index >= _limit) || (string[_index] != literal[i])) {
                _index = saved
    
                if (asserted) {
                    setErrorWithMessage("Missing:\(literal)", location:saved, length:(_index - saved + 1))
                }
    
                return false;
            }
            i = i + 1
            _index = _index + 1
        }
    
        return true
    }
    
    func matchClass(bits: String) -> Bool
    {
        if (_index >= _limit) {
            return false;
        }
    
        var c = _string[_index]
    
        if (bits[c >> 3] & (1 << (c & 7))) {
            _index = _index + 1
            return true
        }
    
        return false;
    }
    
    let _rules = [
//!$ParserRules
    ]
    
}